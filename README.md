# multiplexer

Sharing a server TCP connection between multiple clients


## Usage

```
# Step 1: Creates two named pipes, one for data flowing remote -> local ("up"
# for uplink), another for data flow local -> remote ("down" for downlink)
$ mkfifo up down

# Step 2: Start the multiplexer server:
$ dotnet run -- -u up -d down -p 3333

# Step 3: Connect multiple clients:
# In terminal window 1:
$ telnet localhost 3333
# In terminal window 2:
$ telnet localhost 3333

# Step 4: Connect remote to `up` and `down`:
$ socat TCP4:remote.server:23 'GOPEN:up,nonblock=1!!GOPEN:down'

```

## Introduction

*A little outdated, the remote end is now two named pipes, one for uplink, one
for downlink. And an external tool like `socat` are needed to connect a remote
TCP or whatever data source to the named pipes. This is more general purpose
than the old design.*

This tool allows multiple TCP clients to share a single TCP connection to 
a server. Traffic generated by the server is forwarded to all clients. Traffic
generated from any client is forwarded to the server.

This graph demonstrates the idea

<img src="doc/highlevel.png" width="400">


How is it useful? In many cases, we want to write program to automate tasks
with a remote service, but at the same time want to keep using the existing
tool that doesn't offer the functionality that your automation program is
capable of, but provides an easy/familiar UI, so that your automation program 
won't have to.


## Performance

All TCP connections (server-multiplexer, multiplexer-clients) IO operations
are completely non-blocking. I expect the traffic throughput to be very high.


## Demo

Here's a demonstration of it in action. As an example, in this case, there're
two MUD clients sharing the same connection to the server. Imagine one of the
two clients is a thin program that automates your player, but provides no
ability for human intervention. And the other client is a regular feature-rich
MUD client that you can interact with.

![demo](doc/demo.gif)
